# Let chi be the irreducible character of a group G (that is, the element of Irr(G)).
# The function below computes the Frobenius-Schur indicator of chi.
InstallGlobalFunction( OFPFrobeniusSchurIndicator, function( chi, G )
  return Sum( ConjugacyClasses( G ),
  cl -> ( Size( cl ) * ( Representative(cl)^2 )^chi ) / Order( G ) );
end );

# Let H1 and H2 be the subgroups of a group G.
# The function below computes the subgroup of G generated by the subgroups H1 and H2.
# Assumption: H1 and H2 cannot be simultanously the trivial subgroup of G.
InstallGlobalFunction( OFPGroupGeneratedBySubgroups, function( H1, H2 )
  return Group( Union( SmallGeneratingSet( H1 ), SmallGeneratingSet( H2 ) ) );
end );

# The function below returns the list of all index two subgroups of G
InstallGlobalFunction( OFPIndex2Subgroups, function( G )
  return Filtered( MaximalNormalSubgroups( G ), H -> IndexNC( G, H ) = 2 );
end );

# The function below checks whether a group G is an Oliver group. The reference to the algebraic
#	characterization of Oliver groups from my PhD thesis [2] is Definition 4.1. The characterization is
# as follows. G is an Oliver group iff it does not contain a sequence of sbgroups P<=H<=G such that:
# - P is normal in H and H is normal in G,
# - P and G/H are groups of prime power order (possibly one),
# - H/P is cyclic.
InstallGlobalFunction( OFPIsOliver, function( G )
  local N, H, idx;
  for H in NormalSubgroups( G ) do
    idx := IndexNC( G, H );
    if IsPrimePowerInt( idx ) or IsOne( idx ) then
      for N in NormalSubgroups( H ) do
        if IsPGroup( N ) and IsCyclic( H/N ) then
          return false;
        fi;
      od;
    fi;
  od;
  return true;
end );

# Let 'tuple' be a list of length n of positive integers.
# The function below computes the list of tuples t[1..n] such that
# t[i] <= tuple[i] for 1<=i<=n.
InstallGlobalFunction( OFPLexSmallerTuples, function( tuple )
  local result, tempTuple, coordinateToChange, sizeT;
  tempTuple := List( tuple, x -> 1 );
  result := [];
  sizeT := Size( tuple );
  while tempTuple <> tuple do
    Add( result, Immutable( tempTuple ) );
    coordinateToChange := sizeT;
    while tempTuple[coordinateToChange]+1 > tuple[coordinateToChange] do
      coordinateToChange := coordinateToChange-1;
    od;
    tempTuple[coordinateToChange] := tempTuple[coordinateToChange]+1;
    tempTuple{[(coordinateToChange+1)..sizeT]} := List( [(coordinateToChange+1)..sizeT], x -> 1 );
  od;
  Add( result, tuple );
  return result;
end );

# Let G be a group and realModule be a list of pairs representing characters of a given real G-module:
# - the first entry of the i-th pair is the list of characters evaluated on conjugacy classes of G
#   of the i-th irreducible real G-module,
# - the second entry of the i-th pair is the multiplicity of the i-th irreducible real G-module
#   in realModule.
# The function below computes the values of characters of realModule evaluated on conjugacy classes of G.
InstallGlobalFunction( OFPRealModuleCharacters, function( realModule, G )
  return List( [1..NrConjugacyClasses( G )],
  idx -> Sum( realModule, irrComponent -> irrComponent[1][idx]*irrComponent[2] ) );
end );

# Checks whether the group G satisifes the assumptions of Proposition 2.9 from [1].
InstallGlobalFunction( OFPSatisfiesProposition29, function( G )
  local g, ordg, isppo;
  for g in List( ConjugacyClasses( G ), Representative ) do
    ordg := Order( g );
    isppo := IsPrimePowerInt( ordg );
    if (ordg <> 1 and not isppo) or (isppo and ordg > 4 and IsEvenInt(ordg)) then
      return false;
    fi;
  od;
  return true;
end );
