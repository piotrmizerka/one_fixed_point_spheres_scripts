# To load this file from the project directory (assuming GAP is launched in this directory), call
# Read( Filename( [DirectoryCurrent()], "level_0_functions.g" ) );


# Let chi be the irreducible character of a group G (that is, the element of Irr(G)).
# The function below computes the Frobenius-Schur indicator of chi.
FrobeniusSchurIndicator := function( chi, G )
	return Sum( ConjugacyClasses( G ),
      cl -> ( Size( cl ) * ( Representative(cl)^2 )^chi ) / Order( G ) );
end;

# Let S1 and S2 be the subsets of a group G.
# The function below computes the subgroup of G generated by elements from the union of S1 and S2.
GroupByGeneratingSubsets := function( S1, S2 )
	return GroupByGenerators(Union(S1, S2));
end;

# Let N be a normal subgroup of G.
# The function below computes the quotient group G/N.
QuotientGroup := function( G, N )
	return Image( NaturalHomomorphismByNormalSubgroup( G, N ) );
end;

# Let G be a group and realModule be a list of pairs representing characters of a given real G-module:
# - the first entry of the i-th pair is the list of characters evaluated on conjugacy classes of G
#   of the i-th irreducible real G-module,
# - the second entry of the i-th pair is the multiplicity of the i-th irreducible real G-module
#   in realModule.
# The function below computes the values of characters of realModule evaluated on conjugacy classes of G.
RealModuleCharacters := function( realModule, G )
	return List( [1..NrConjugacyClasses( G )],
      idx -> List(realModule, irrComponent -> First(irrComponent)[idx]*Last(irrComponent)) );
end;

LexSmallerTuples := function( tuple )
    local result;
# TODO: refactor RestrictedTuples to LexSmallerTuples
    return result;
end;

# TODO better name
LexSmallerTuples_ := function( listOfTuples)
    retun List( listOfTuples, LexSmallerTuples );
end;

# Let 'restrictions' be a list of length n of positive integers.
# The function below computes the list of tuples t[1..n] such that
# t[i] <= restrictions[i] for 1<=i<=n.
RestrictedTuples := function( restrictions )
	local result, tuple, finalTuple, res, coord, value, i, temp, tuple2;
	finalTuple := [];
	tuple := [];
	coord := Size( restrictions );
	value := 1;
	result := [];
	for res in restrictions do
		Add( finalTuple, res );
		Add( tuple, 1 );
	od;
	temp := 1;
	while tuple <> finalTuple and temp < 100 do # 100?
		tuple2 := [];
		for i in [1..Size( restrictions )] do
			Add( tuple2, tuple[i] );
		od;
		Add( result, tuple2 );
		while tuple[coord]+1 > restrictions[coord] do
			coord := coord-1;
		od;
		tuple[coord] := tuple[coord]+1;
		for i in [(coord+1)..Size(restrictions)] do
			tuple[i] := 1;
		od;
		coord := Size( restrictions );
		temp := temp+1;
	od;
	Add( result, finalTuple );
	return result;
end;

# Checks whether the group G satisifes the assumptions of Proposition 2.9 from [1].
SatisfiesProposition29 := function( G )
	local g, ordg, isppo;
	for g in List( ConjugacyClasses( G ), Representative ) do
	    ordg := Order( g );
	    isppo := IsPrimePowerInt( ordg );
		if (ordg <> 1 and not isppo) or (isppo and ordg > 4 and IsEvenInt(ordg)) then
			 return false;
		fi;
	od;
	return true;
end;
